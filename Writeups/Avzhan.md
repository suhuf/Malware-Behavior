

Hello, today we are going to do a dynamic analysis of the behavior of the Avzhan Malware. There are multiple advanced write-ups available of this malware. Of the best of them, MalwareByte's as found here (https://www.malwarebytes.com/blog/news/2018/02/avzhan-ddos-bot-dropped-by-chinese-drive-by-attack).

**Run down of Avzhan:**

Avzhan is a malware, most likely released from China, that transforms its victim's machines into DDoS bots. The main behavior of the malware is the task DDoS attacks and other commands from its respective CNC (Command and Control) center/server.

In this case, Avzhan, when first run, copies itself into the System32 directory with a randomly generated 6-character name. Deletes its exe of origin, and makes a new exe that is used to take commands from its CNC (Command and Control center). 

It also runs a service via the Windows API Under **Services/gtrey** that has a display name of **'Juyi'** (Static) and a description of **"Tuy"**. Now Let's get to some dynamic analysis.



**Regishot:**


We take our first Regishot and then run the malware with admin privileges and then compare...


**![image](https://github.com/suhuf/Malware-Behavior/assets/105312929/60781f97-1960-4e09-a88e-af331cbc8375)
**

The first thing we notice is that the .Exe has deleted itself. This is a common evasive tactic of malware. Usually, the malware will copy itself to another Exe under a randomly generated name and start a service to mask its malicious intent and not give an easy IoC. Let's see if we can find where it has put itself to:


We can check files between the two snapshots in Regishot and we specifically see an Exe that does not look typical with Windows systems:

![image](https://github.com/suhuf/Malware-Behavior/assets/105312929/0e8e4889-63bf-43bc-ae7e-26f619947284)

**Windows\Syswow64\Xonoo.exe**

This is the location that the exe has copied itself to, using a randomly generated name which in this case is Xonoo.

(Note that I had to re-run the malware more than once so this randomly generated name might be different later in this paper).

Now let's see if we can find a service that it is using:

![image](https://github.com/suhuf/Malware-Behavior/assets/105312929/c460089f-6aed-464c-8002-5315809da8c4)


Now under **'gtey'**, an uncommon service directory name, we find a service that directly uses the suspicious exe we noted earlier. It has a Display name of 'juyi' and a description of 'tuy'. These are both statically assigned, and as a result, are important to note as they could be Indicators of Compromise on other systems.


Now that we have details regarding service name and description, we can refer to these to identify the malware even if it hides itself under a different name.

Besides that, some registry edits are also used by the malware for persistence.


**Process Explorer:**

Now let's investigate a bit more of what the malware is doing on our system. When checking Process Explorer, it was very difficult to locate the copied exe when the network adapter was offline. 

However, once the network adapter was turned on (On host only) the exe immediately appeared in process explorer:


![image](https://github.com/suhuf/Malware-Behavior/assets/105312929/73d5325d-1fe7-4fd2-be4b-09f1fa2b81e9)

(**Note:** It is a different randomly generated 6 characters as I re-ran the malware after reverting my snapshot)


We can look for more info on this newly created exe here. 

![image](https://github.com/suhuf/Malware-Behavior/assets/105312929/9e215bfa-545e-4c91-bd91-70d7c39edba0)

We also can check the strings of the program via Process Explorer where we first find this:

![image](https://github.com/suhuf/Malware-Behavior/assets/105312929/bfc5c9e7-e79d-45bb-b8f3-7b876c0a5fd3)

This is a malformed Get request that is sometimes used in DoS attacks.


Looking further into the strings of the exe we have more evidence it has the functionality to make HTTP requests:

![image](https://github.com/suhuf/Malware-Behavior/assets/105312929/4ec9f7bc-d831-464a-baae-73068e6c29a1)

We can see it spoofs its referer, user agent, and other details. Of interesting note is that its default language is also Chinese. 

![image](https://github.com/suhuf/Malware-Behavior/assets/105312929/a9c2cda0-840a-49c6-96b6-fcae016eb040)

However, with all of this, we still are unable to identify a static IP address.

Looking further in the strings, however, we do find some very important information:

![image](https://github.com/suhuf/Malware-Behavior/assets/105312929/b2f7c6dd-6ac7-4d73-af7d-dc102ed5420b)

Firstly, we find a hostname that the malware refers to **'xhsb.3322.org'**. We also find functionality that allows the malware to download a URL to a file **'URLDownloadToFileA'**.

Now that we have a host name we can look further into the malware's behavior on the networking side.


More info on 'xhsb.3322.org'; this was a famous Chinese DNS server that was commonly used by botnets and other malware. There was a huge number of bots that relied on this server to resolve DNS requests. This server was 'Controversially' taken down by Microsoft in around 2012. You can read more about it here: (https://circleid.com/posts/20120917_microsoft_takedown_of_3322_org_a_gigantic_self_goal) (https://krebsonsecurity.com/2012/09/malware-dragnet-snags-millions-of-infected-pcs/).


**Networking Portion**


**[Networking Setup]**

Here, I am going to run 2 VMs at once both on host only. VMware has designed its network to work so that when 2 VMs are running on host only, they can communicate with each other as long as they are on the same Subnet. 

To do this yourself, set your Windows VM to be on the same subnet as your other box spoofing DNS, and then test connectivity via ping. Instructions for Ubuntu distributions are provided here: https://www.freecodecamp.org/news/setting-a-static-ip-in-ubuntu-linux-ip-address-tutorial/ .


In this case, we are going to use FakeDns(.py) on Remnux. As a result, everything that attempts to communicate from the Windows VM is going to be sent to the Remnux box **including** all Windows telemetry.

The network settings on the Windows VM need to have **1. Same Subnet** **2. Its Default gateway as the IP of the other VM.**

If you can ping both machines back and forth you should be good.


**[Networking Analysis]**

On the host VM we can use a tool developed by Mike Murr that also comes pre-installed on Remnux called **"FakeDNS(.py)"**. This lets our Remnux VM spoof as a DNS server and also resolve requests to itself:

We can either revert the Windows VM to a snapshot and re-run the malware or we can just continue like this, it should work regardless as long as the network adapter is enabled (On Host only).

First, we run FakeDNS on the Remnux machine via 'FakeDNS'. Then we should see some requests that the spoofed DNS is resolving:

![image](https://github.com/suhuf/Malware-Behavior/assets/105312929/447ee052-c876-4161-bcd0-fef1b4b2ebe4)

Here we can see a few DNS requests. Most of them are telemetry and we can ignore all of them except for the request to **xhsb.3222.org.** this proves that the malware is communicating with his malicious DNS server.

Let's analyze the network request on the Windows VM's end:

![image](https://github.com/suhuf/Malware-Behavior/assets/105312929/fe2b4657-d06c-4eae-9827-e582bd3fe5d7)


When checking Wireshark we see the malware clearly makes a DNS request to the spoofed DNS Server, it is then given an IP address (which is just our remnux VM) and then attempts to connect to the remnux machine on port 1988 (Static) via port 61661 (Dynamic) thinking it is its CNC.

![image](https://github.com/suhuf/Malware-Behavior/assets/105312929/224dfb7f-e8bf-44d8-908f-ef37b6b2887f)

However we are not running anything on port 1988. As a result RST packet is sent and the connection is refused. (The SYN handshake is never completed).

In order to find out what is being sent by the malware we need to get past the SYN handshake and get info on some actual data. So we need to start a service on port 1988.

For this we are going to use NC first and then test what is done with a simple python Http server.

We are going to keep FakeDNS open in one terminal and start Netcat with this command on another: **'nc -l -p 1988'**  which basically means 'Listen on this port.'

![image](https://github.com/suhuf/Malware-Behavior/assets/105312929/d71d1eed-bdb0-4b7d-be82-9b9d5998ab61)

And with that we are almost immediately sent system information via the malware.

When checking in Wireshark we can also see the exact packet that was sent:

![image](https://github.com/suhuf/Malware-Behavior/assets/105312929/5d43a640-49a6-4013-a833-c76be3186f3f)

And there we have it. The malware has sent its beacon to the CNC. Now there isnt much the malware is going to do since it is waiting for commands from its CNC, and unfortanantely I have not yet found any writeup going in detail regarding the format of the commands that the malware is expecting. But lets try starting a python server on port 1988 and seeing how the malware reacts.

We are going to use this command: **python3 -m http.server 1988**

![image](https://github.com/suhuf/Malware-Behavior/assets/105312929/7e8dd143-a0d3-4e66-bad7-1024b005314e)

After waiting for a while ... still no response.


It seems like the malware has no interaction with the CNC server when the CNC is acting as a webserver alone, seems like we can scratch that off. 


This is the end of my analysis for now, I am trying to find a way to emulate CNC commands to the infected machine. But till then See ya!





























